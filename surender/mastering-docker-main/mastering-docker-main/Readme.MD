# Docker Overview

Docker is an open platform for developing, shipping, and running applications. Docker enables you to separate your applications from      your infrastructure so you can deliver software quickly. With Docker, you can manage your infrastructure in the same ways you manage    your applications. By taking advantage of Docker’s methodologies for shipping, testing, and deploying code quickly, you can              significantly reduce the delay between writing code and running it in production.`

## The Docker platform

Docker provides the ability to package and run an application in a loosely isolated environment called a container. The isolation and security allow you to run many containers simultaneously on a given host.


## Docker Engine

_Docker Engine_ is a client-server application with these major components:

- A server which is a type of long-running program called a daemon process (the dockerd command). 
- A REST API which specifies interfaces that programs can use to talk to the daemon and instruct it what to do. 
- A command line interface (CLI) client (the docker command).

## What can I use Docker for?

### 

Fast, consistent delivery of your applications

Docker streamlines the development lifecycle by allowing developers to work in standardized environments using local containers which provide your applications and services. Containers are great for continuous integration and continuous delivery (CI/CD) workflows.

Consider the following example scenario:

- Your developers write code locally and share their work with their colleagues using Docker containers.
- They use Docker to push their applications into a test environment and execute automated and manual tests.
- When developers find bugs, they can fix them in the development environment and redeploy them to the test environment for testing and validation.
- When testing is complete, getting the fix to the customer is as simple as pushing the updated image to the production environment.

### Docker architecture

### 

Docker uses a client-server architecture. The Docker _client_ talks to the Docker _daemon_, which does the heavy lifting of building, running, and distributing your Docker containers. The Docker client and daemon _can_ run on the same system, or you can connect a Docker client to a remote Docker daemon. The Docker client and daemon communicate using a REST API, over UNIX sockets or a network interface

#### The Docker daemon

#### 

The Docker daemon (dockerd) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. A daemon can also communicate with other daemons to manage Docker services.

#### The Docker client

#### 

The Docker client (docker) is the primary way that many Docker users interact with Docker. When you use commands such as, the client sends these commands to, which carries them out. The command uses the Docker API. The Docker client can communicate with more than one daemon.

#### Docker registries

#### 

A Docker _registry_ stores Docker images. Docker Hub is a public registry that anyone can use, and Docker is configured to look for images on Docker Hub by default. You can even run your private registry. If you use Docker Datacenter (DDC), it includes Docker Trusted Registry (DTR).

## The underlying technology


Docker is written in [Go](https://golang.org/) and takes advantage of several features of the Linux kernel to deliver its functionality.

**Namespaces**

Docker uses a technology called 

namespaces to provide the isolated workspace called the _container_. When you run a container, Docker creates a set of _namespaces_ for that container.

These namespaces provide a layer of isolation. Each aspect of a container runs in a separate namespace and its access is limited to that namespace.

Docker Engine uses namespaces such as the following on Linux:

- The **pid** namespace: Process isolation (PID: Process ID).
- The **net** namespace: Managing network interfaces (NET: Networking).
- The **ipc** namespace: Managing access to IPC resources (IPC: InterProcess Communication).
- The **mnt** namespace: Managing filesystem mount points (MNT: Mount).
- The **uts** namespace: Isolating kernel and version identifiers. (UTS: Unix Timesharing System).

**Control groups**

Docker Engine on Linux also relies on another technology called _control groups_ (cgroups). A cgroup limits an application to a specific set of resources. Control groups allow Docker Engine to share available hardware resources to containers and optionally enforce limits and constraints. For example, you can limit the memory available to a specific container.

**Union file systems**

Union file systems, or UnionFS, are file systems that operate by creating layers, making them very lightweight and fast. Docker Engine uses UnionFS to provide the building blocks for containers. Docker Engine can use multiple UnionFS variants, including AUFS, btrfs, vfs, and DeviceMapper.

**Container format**

Docker Engine combines the namespaces, control groups, and UnionFS into a wrapper called a container format. The default container format is libcontainer. In the future, Docker may support other container formats by integrating with technologies such as BSD Jails or Solaris Zone



# Get Docker Engine - Community for CentOS

## OS requirements

- To install Docker Engine - Community, you need a maintained version of CentOS 7

- The centos-extras repository must be enabled. This repository is enabled by default, but if you have disabled it, you need to re-enable it.

- The overlay2 storage driver is recommended.

## Install Docker Engine - Community

- Configiure Docker **repository** and install from them. This is easy and recommended approach.
- Download **RPMs packages** manually and install. This installation is recommended for systems without internet connections
- Install using docker **script**

## Install using the repository

Before you install Docker Engine - Community for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository.

## SET UP THE REPOSITORY

1. Install required packages

    ```sh
    sudo yum install -y yum-utils device-mapper-persistent-data lvm2
    ```
2. Set up the stable repository

    ```sh
    yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
    ```

## INSTALL DOCKER ENGINE - COMMUNITY

1. Install the latest version of Docker Engine - Community and containerd

    ```sh
    yum install docker-ce docker-ce-cli containerd.io
    ```

2. Start Docker.
    ```sh
    systemctl start docker
    ```

3. Verify that Docker Engine - Community is installed correctly by running the hello-world image.
    ```sh
    docker run hello-world
    ```

## Install using the convenience script

```sh
$ curl -fsSL https://get.docker.com -o get-docker.sh
$ sudo sh get-docker.sh
```
